#Первая программа

#print("Hello World")

# str_format.py

# age = 26
# name = "Swaroop"

# print("Возраст {0} -- {1} год.".format(name,age))
# print("Почему {0} забавляется с этим Python?".format(name))

# #десятичное число (.) с точностью в 3 знака для плавающих:
# print("{0:.3}".format(1/3))
# #заполните подчеркиваниями(_) с центровкой текста (^) по ширине 11:
# print("{0:_^11}".format("hello"))
# #по ключевым словам:
# print("{name} написал {book}".format(name = "Swaroop", book = "A Byte of Python"))

#Имя файла : var.py

# i = 5
# print(i)
# i = i + 1
# print(i)
# s = """Это многострочная строка.
# Это вторая её строчка."""
# print(s)
# i = 5; print(i)
# s = "Это строка. \
# Это строка продолжается"
# print(s)
# print\
# (s)

# expression.py

# lenght = 5

# breadth = 2 

# area = lenght * breadth

# print("Площадь равна: ", area)
# print("Периметр равен: ", 2 * (lenght + breadth))

# Как это работает:
# Длина и ширина прямоугольника хранятся в переменных length и breadth
# соответственно. Мы используем их для вычисления периметра и площади
# прямоугольника при помощи выражений. Результат выражения length *
# breadth сохраняется в переменной area, после чего выводится на экран
# функцией print. Во втором случае мы напрямую подставляем значение выражения 2 * (length + breadth) в функцию print.
# Также обратите внимание, как Python «красиво печатает» результат. Несмотря на то, что мы не указали пробела между 'Площадь равна' и переменной area, Python подставляет его за нас, чтобы получить красивый и понятный вывод. Программа же остаётся при этом легкочитаемой (поскольку нам
# не нужно заботиться о пробелах между строками, которые мы выводим). Это
# пример того, как Python облегчает жизнь программисту.



# if.py

# number = 23
# guess = int(input("Введите целое число: "))

# if guess == number:
#     print("Поздравляю, Вы угадали, ") # Начало нового блока
#     print("(хотя и не выиграли никакого приза!)") # Конец нового блока
# elif guess < number:
#     print("Нет, загаданное число немного больше этого.") # Eщё один блок
#     # Внутри блока Вы можете выполнять всё, что угодно ... 
# else:
#     print("Нет загаданное число немного меньше этого.")
#     # чтобы попасть сюда, guess должно быть больше чем number
# print("Завершено")
# # Это последнее выражение выполняется всегда после выполнения оператора if

# Как это работает:
# В этой программе мы принимаем варианты от пользователя и проверяем, совпадают ли они с заранее заданным числом. Мы устанавливаем переменной
# number значение любого целого числа, какого хотим. Например, 23. После
# этого мы принимаем вариант числа от пользователя при помощи функции
# input(). Функции – это всего-навсего многократно используемые фрагменты программы. Мы узнаем о них больше в следующей главе.
# Мы передаём встроенной функции input строку, которую она выводит на
# экран и ожидает ввода от пользователя. Как только мы ввели что-нибудь и нажали клавишу Enter, функция input() возвращает строку, которую мы ввели. Затем мы преобразуем полученную строку в число при помощи int(),
# и сохраняем это значение в переменную guess. Вообще-то, int – это класс,
# но на данном этапе вам достаточно знать лишь, что при помощи него можно
# преобразовать строку в целое число (предполагая, что строка содержит целое
# число).
# Далее мы сравниваем число, введённое пользователем, с числом, которое мы
# выбрали заранее. Если они равны, мы печатаем сообщение об успехе. Обратите внимание, что мы используем соответствующие уровни отступа, чтобы
# указать Python, какие выражения относятся к какому блоку. Вот почему отступы так важны в Python. Я надеюсь, вы придерживаетесь правила «постоянных
# отступов», не так ли?
# Обратите внимание, что в конце оператора if стоит двоеточие – этим мы по
# казываем, что далее следует блок выражений.
# После этого мы проверяем, верно ли, что пользовательский вариант числа
# меньше загаданного, и если это так, мы информируем пользователя о том,
# что ему следует выбирать числа немного больше этого. Здесь мы использовали выражение elif, которое попросту объединяет в себе два связанных if
# else-if else выражения в одно выражение if-elif-else. Это облегчает
# чтение программы, а также не требует дополнительных отступов.
# Выражения elif и else также имеют двоеточие в конце логической строки,
# за которым следуют соответствующие блоки команд (с соответствующим числом отступов, конечно).
# Внутри if-блока оператора if может быть другой оператор if и так далее – это
# называется вложенным4 оператором if.
# Помните, что части elif и else не обязательны. Минимальная корректная
# запись оператора if такова:
# if True:
# print('Да, это верно.')
# После того, как Python заканчивает выполнение всего оператора if вместе с
# его частями elif и else, он переходит к следующему выражению в блоке,
# содержащем этот оператор if. В нашем случае это основной блок программы
# (в котором начинается выполнение программы), а следующее выражение –
# это print('Завершено'). После этого Python доходит до конца программы и
# просто выходит из неё.


# while.py

# number = 23
# running = True

# while running:
#     guess = int(input("Введите целое число: "))

#     if guess == number:
#         print("Поздравляю, Вы угадали.")
#         running = False # Это останавливает цикл while
#     elif guess < number:
#         print("Нет, загаданное число немного больше этого.")
#     else:
#         print("Нет загаданное число немного меньше этого.")
# else:
#     print("Цикл while закончен.")
#     # Здесь можете выполнить всё что Вам ещё нужно.
# print("Завершение.")

# Как это работает:
# В этой программе мы продолжаем играть в игру с угадыванием, но преимущество состоит в том, что теперь пользователь может угадывать до тех пор,
# пока не угадает правильное число, и ему не придётся запускать программу
# заново для каждой попытки, как это происходило до сих пор. Это наглядно
# демонстрирует применение оператора while.
# Мы переместили операторы input и if внутрь цикла while и установили

# for.py

# for i in range(1,5):
#     print(i)
# else:
#     print("Цикл for завершен")

# Как это работает:
# В этой программе мы выводим на экран последовательность чисел. Мы генерируем эту последовательность, используя встроенную функцию range5
# .
# Мы задаём два числа, и range возвращает последовательность чисел от первого числа до второго. Например, range(1,5) даёт последовательность [1, 2,
# 3, 4]. По умолчанию range принимает значение шага, равное 1. Если мы
# зададим также и третье число range, оно будет служить шагом. Например,
# range(1,5,2) даст [1,3]. Помните, интервал простирается только до второго числа, т.е. не включает его в себя.
# Обратите внимание, что range() генерирует последовательность чисел, но
# только по одному числу за раз – когда оператор for запрашивает следующий элемент. Чтобы увидеть всю последовательность чисел сразу, используйте list(range()). Списки6 подробно рассматриваются в главе Структуры
# данных.
# Затем цикл for осуществляет итерацию по этому диапазону - for i in
# range(1,5) эквивалентно for i in [1, 2, 3, 4], что напоминает присваивание переменной i по одному числу (или объекту) за раз, выполняя блок
# команд для каждого значения i. В данном случае в блоке команд мы просто
# выводим значение на экран.


# break.py

# while True:
#     s = input("Введите что-нибудь: ")
#     if s == "Выход":
#         break
#     print("Длина строки:", len(s))
# print("Завершение")

# Как это работает:
# В этой программе мы многократно считываем пользовательский ввод и выводим на экран длину каждой введённой строки. Для остановки программы мы
# вводим специальное условие, проверяющее, совпадает ли пользовательский
# ввод со строкой 'выход'. Мы останавливаем программу прерыванием цикла
# оператором break и достигаем её конца.
# Длина введённой строки может быть найдена при помощи встроенной функции len.
# Помните также, что оператор break может применяться и в цикле for.


# continue.py

# while True:
#     s = input("Введите что-нибудь: ")
#     if s == "Выход":
#         break
#     if len(s) < 3:
#         print("Слишком мало")
#         continue
#     print("Введенная строка достаточной длины")
    # Разные другие действия здесь...

#     Как это работает:
# В этой программе мы запрашиваем ввод со стороны пользователя, но обрабатываем введённую строку только если она имеет длину хотя бы в 3 символа.
# Итак, мы используем встроенную функцию len для получения длины строки,
# и если длина менее 3, мы пропускаем остальные действия в блоке при помощи оператора continue. В противном случае все остальные команды в цикле
# выполняются, производя любые манипуляции, которые нам нужны.
# Заметьте, что оператор continue также работает и с циклом for.

# expression.py

# lenght = 5

# breadth = 2 

# area = lenght * breadth

# print("Площадь равна: ", area)
# print("Периметр равен: ", 2 * (lenght + breadth))

# if.py

# number = 23
# guess = int(input("Введите целое число: "))

# if guess == number:
#     print("Поздравляю, Вы угадали, ") # Начало нового блока
#     print("(хотя и не выиграли никакого приза!)") # Конец нового блока
# elif guess < number:
#     print("Нет, загаданное число немного больше этого.") # Eщё один блок
#     # Внутри блока Вы можете выполнять всё, что угодно ... 
# else:
#     print("Нет загаданное число немного меньше этого.")
#     # чтобы попасть сюда, guess должно быть больше чем number
# print("Завершено")
# Это последнее выражение выполняется всегда после выполнения оператора if

# function1.py
# def sayHello():#     print("Привет мир!") # блок принадлежащий функции 
# # конец функции 
# sayHello() # вызов функции# sayHello() # ещё один вызов функции
# Мы определили функцию с именем sayHello, используя описанный выше
# синтаксис. Эта функция не принимает параметров, поэтому в скобках не объявлены какие-либо переменные. Параметры функции – это некие входные# данные, которые мы можем передать функции, чтобы получить соответствующий им результат.
#Обратите внимание, что мы можем вызывать одну и ту же функцию много#раз, а значит нет необходимости писать один и тот же код снова и снова.
# func_param.py
# def printMax(a, b):
#     if a > b:#         print(a, "максимально")
#     elif a == b:#         print(a, "равно", b)
#     else:
#         print(b, "максимально")# printMax(3, 4) # прямая передача значений 
# x = 5
# y = 7 
# printMax(x, y) # передача переменных в качестве аргументов 
# Здесь мы определили функцию с именем printMax, которая использует два# параметра с именами a и b. Мы находим наибольшее число с применением
# простого оператора if..else и выводим это число.# При первом вызове функции printMax мы напрямую передаём числа в качестве аргументов. Во втором случае мы вызываем функцию с переменными
# в качестве аргументов. printMax(x, y) назначает значение аргумента x параметру a, а значение аргумента y – параметру b. В обоих случаях функция# printMax работает одинаково.

# func_local
# x = 50 
# def func(x):
#     print("x равен", x)#     x = 2 
#     print("Замена локального x на", x)    
# func(x)# print("x по-прежнему", x)
# При первом выводе значения, присвоенного имени x, в первой строке функции
# Python использует значение параметра, объявленного в основном блоке, выше# определения функции.
# Далее мы назначаем x значение 2. Имя x локально для нашей функции. Поэтому когда мы заменяем значение x в функции, x, объявленный в основном# блоке, остаётся незатронутым.
# Последним вызовом функции print мы выводим значение x, указанное в основном блоке, подтверждая таким образом, что оно не изменилось при локальном присваивании значения в ранее вызванной функции.

# func_global.py 
 
# func_local
# x = 50 
# def func(x):
#     print("x равен", x)#     x = 2 
#     print("Замена локального x на", x)    
# func(x)# print("x по-прежнему", x)
# При первом выводе значения, присвоенного имени x, в первой строке функции
# Python использует значение параметра, объявленного в основном блоке, выше# определения функции.
# Далее мы назначаем x значение 2. Имя x локально для нашей функции. Поэтому когда мы заменяем значение x в функции, x, объявленный в основном# блоке, остаётся незатронутым.
# Последним вызовом функции print мы выводим значение x, указанное в основном блоке, подтверждая таким образом, что оно не изменилось при локальном присваивании значения в ранее вызванной функции.

# func_global.py 
# x = 50 
# def func():   
#     global x 
    
#     print("x равно", x)    
#     x = 2 
#     print("Заменяем глобальное значение x на", x)    
# func()
# print("Значение x составляет", x)

# Зарезервированное слово global используется для того, чтобы объявить, что# x – это глобальная переменная, а значит, когда мы присваиваем значение имени x внутри функции, это изменение отразится на значении переменной x в
# основном блоке программы.# Используя одно зарезервированное слово global, можно объявить сразу
# несколько переменных: global x, y, z.

# Зарезервированное слово global используется для того, чтобы объявить, что# x – это глобальная переменная, а значит, когда мы присваиваем значение имени x внутри функции, это изменение отразится на значении переменной x в
# основном блоке программы.# Используя одно зарезервированное слово global, можно объявить сразу
# несколько переменных: global x, y, z.


# func_nonlocal.py

# def func_outer():
#     x = 2 
#     print("x равно", x)
    
#     def func_inner():
#         nonlocal x
#         x = 5
        
#     func_inner()
#     print("Локальное x сменилось на", x)

# func_outer()
# Когда мы находимся внутри func_inner, переменная x, определённая в первой строке func_outer находится ни в локальной области видимости (определение переменной не входит в блок func_inner), ни в глобальной области видимости (она также и не в основном блоке программы). Мы объявляем, что хотим использовать именно эту переменную x, следующим образом:
# nonlocal x.
# Попробуйте заменить «nonlocal x» на «global x», а затем удалить это зарезервированное слово, и пронаблюдайте за разницей между этими двумя
# случаями.

# func_default.py 

# def say(message, times = 1):
#     print(message * times)

# say("Привет")
# say("Мир", 5)

# Функция под именем say используется для вывода на экран строки указанное
# число раз. Если мы не указываем значения, по умолчанию строка выводится
# один раз. Мы достигаем этого указанием значения аргумента по умолчанию,
# равного 1 для параметра times2
# .
# При первом вызове say мы указываем только строку, и функция выводит её
# один раз. При втором вызове say мы указываем также и аргумент 5, обозначая
# таким образом, что мы хотим сказать3 фразу 5 раз.

# func_key.py

# def func(a, b = 5, c = 10):
#     print("a равно",a,", b равно",b,", a c равно", c)
    
# func(3, 7)
# func(25, c = 24)
# func(c = 50, a = 100)

# Функция с именем func имеет один параметр без значения по умолчанию, за
# которым следуют два параметра со значениями по умолчанию.
# При первом вызове, func(3, 7), параметр a получает значение 3, параметр
# b получает значение 7, а c получает своё значение по умолчанию, равное 10.
# При втором вызове func(25, c=24) переменная a получает значение 25 в
# силу позиции аргумента. После этого параметр c получает значение 24 по
# имени, т.е. как ключевой параметр. Переменная b получает значение по умолчанию, равное 5.
# При третьем обращении func(c=50, a=100) мы используем ключевые аргументы для всех указанных значений. Обратите внимание на то, что мы указываем значение для параметра c перед значением для a, даже несмотря на
# то, что в определении функции параметр a указан раньше c.

# function_varags.py

# def total(a = 5, *numbers, **phonebook):
#     print("a", a)
    
#     #проход по всем элементам кортежа
#     for single_item in numbers:
#         print("single_item", single_item)
        
#     #проход по всем элементам словаря
#     for first_part, second_part in phonebook.items():
#         print(first_part, second_part)
        
# print(total(10,1,2,3,Jack = 1123,John = 2231,Inge = 1560))

# Когда мы объявляем параметр со звёздочкой (например, *param), все позиционные аргументы начиная с этой позиции и до конца будут собраны в кортеж
# под именем param.
# Аналогично, когда мы объявляем параметры с двумя звёздочками (**param),
# все ключевые аргументы начиная с этой позиции и до конца будут собраны в
# словарь под именем param.
# Мы изучим кортежи и словари в одной из последующих глав.

# keyword_only.py

# def total(initial=5, *numbers, extra_number):
#     count = initial
#     for number in numbers:
#         count += number
#     count += extra_number
#     print(count)
    
# total(10, 1, 2, 3, extra_number=50)
# total(10, 1, 2, 3)

# Вызовет ошибку, поскольку мы не указали значение
# аргумент по умолчанию для "extra_number"
# Объявление параметров после параметра со звёздочкой даёт только ключевые
# аргументы. Если для таких аргументов не указано значение по умолчанию, и
# оно не передано при вызове, обращение к функции вызовет ошибку, в чём мы
# только что убедились.
# Обратите внимание на использование +=, который представляет собой сокращённый оператор, позволяющий вместо x = x + y просто написать x += y.
# Если вам нужны аргументы, передаваемые только по ключу, но не нужен параметр со звёздочкой, то можно просто указать одну звёздочку без указания
# имени: def total(initial=5, *, extra_number).

# func_return.py

# def maximum(x, y):
#     if x > y:
#         return x 
#     elif x == y:
#         return "Числа равны"
#     else:
#         return y

# print(maximum(2,3))

# Функция maximum возвращает максимальный из двух параметров, которые в
# данном случае передаются ей при вызове. Она использует обычный условный
# оператор if..else для определения наибольшего числа, а затем возвращает
# это число.
# Обратите внимание, что оператор return без указания возвращаемого значения эквивалентен выражению return None. None – это специальный тип данных в Python, обозначающий ничего. К примеру, если значение переменной установлено в None, это означает,
# что ей не присвоено никакого значения.
# Каждая функция содержит в неявной форме оператор return None в конце, если вы
# не указали своего собственного оператора return. В этом можно убедиться, запустив
# print(someFunction()), где функция someFunction – это какая-нибудь функция, не
# имеющая оператора return в явном виде. Например:
# def someFunction():
# pass
# Оператор pass используется в Python для обозначения пустого блока команд.

# func_doc.py

# def printMax(x, y):
#     """Выводит максимальное из двух чисел.
    
#     Оба значения должны быть целыми числами."""
#     x = int(x) # конвертируем в целые, если возможно
#     y = int(y)
    
#     if x > y:
#         print(x, "наибольшее")
#     else:
#         print(y, "наибольшее")
        
# printMax(3, 5)
# print(printMax.__doc__)

# Строка в первой логической строке функции является строкой документации
# для этой функции. Обратите внимание на то, что строки документации применимы также к модулям и классам, о которых мы узнаем в соответствующих
# главах.
# Строки документации принято записывать в форме многострочной7
# строки,
# где первая строка начинается с заглавной буквы и заканчивается точкой. Вторая строка оставляется пустой, а подробное описание начинается с третьей.
# Вам настоятельно рекомендуется следовать такому формату для всех строк
# документации всех ваших нетривиальных функций.
# Доступ к строке документации функции printMax можно получить с помощью атрибута этой функции (т.е. имени, принадлежащего ей) doc (обратите внимание на двойное подчёркивание). Просто помните, что Python представляет всё в виде объектов, включая функции. Мы узнаем больше об объектах в главе о классах.

# import sys

# print("Аргументы командной строки: ")
# for i in sys.argv:
#     print(i)
    
# print("\n\nПеременная PYTHONPATH содержит", sys.path, "\n")

# В начале мы импортируем модуль sys командой import. Этим мы говорим
# Python, что хотим использовать этот модуль. Модуль sys содержит функции,
# относящиеся к интерпретатору Python и его среде, т.е. к системе (system).
# Когда Python выполняет команду import sys, он ищет модуль sys. В данном
# случае это один из встроенных модулей, и Python знает, где его искать.
# Если бы это был не скомпилированный модуль, т.е. модуль, написанный на
# Python, тогда интерпретатор Python искал бы его в каталогах, перечисленных
# в переменной sys.path. Если модуль найден, выполняются команды в теле
# модуля, и он становится доступным. Обратите внимание, что инициализация1
# происходит только при первом импорте модуля.
# Доступ к переменной argv в модуле sys предоставляется при помощи точки,
# т.е. sys.argv. Это явно показывает, что это имя является частью модуля sys.
# Ещё одним преимуществом такого обозначения является то, что имя не конфликтует с именем переменной argv, которая может использоваться в вашей
# программе.
# Переменная sys.argv является списком строк (списки будут детально обсуждаться в одной из последующих глав). Она содержит список аргументов командной строки, т.е. аргументов, переданных программе из командной строки.
# Если вы используете среду разработки2 для написания и запуска программ,
# поищите где-нибудь в её меню возможность передавать параметры командной строки.
# В нашем примере, когда мы запускаем «python using_sys.py we are
# arguments», мы запускаем модуль using_sys.py командой python, а всё,
# что следует далее – аргументы, передаваемые программе3
# . Python сохраняет
# аргументы командной строки в переменной sys.argv для дальнейшего использования.
# Помните, что имя запускаемого сценария4
# всегда является первым аргументом в списке sys.argv. Так что в приведённом примере 'using_sys.py' будет элементом sys.argv[0], 'we' – sys.argv[1], 'are' – sys.argv[2], а
# 'arguments' – sys.argv[3]. Помните, что в Python нумерация начинается с
# 0, а не с 1.
# sys.path содержит список имён каталогов, откуда импортируются модули.
# Заметьте, что первая строка в sys.path пуста; эта пустая строка показывает,
# что текущая директория также является частью sys.path, которая совпадает
# со значением переменной окружения PYTHONPATH. Это означает, что модули, расположенные в текущем каталоге, можно импортировать напрямую. В
# противном случае придётся поместить свой модуль в один из каталогов, перечисленных в sys.path.
# Помните, что текущий каталог – это каталог, в котором была запущена программа. Выполните «import os; print(os.getcwd())», чтобы узнать текущий каталог программы.

# Пример(простое, непростое число)

# from math import *

# n = int(input("Введите диапазон:-  "))
# p = [2, 3]
# count = 2 
# a = 5 
# while (count < n):
#     b = 0 
#     for i in range(2, a):
#         if (i <= sqrt(a)):
#             if (a % i == 0):
#                 print(a,"непростое")
#                 b = 1
#             else:
#                 pass
        
#     if (b != 1):
#         print(a,"простое")
#         p = p + [a]
#     count = count + 1 
#     a = a + 2 
# print(p)

# using_name.

# if __name__ == "__main__":
#     print("Эта программа запущена сама по себе.")
# else:
#     print("Меня импортировали в другой модуль.")




